import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Database, FileCode2, AlertTriangle, AlertCircle, Trash2, Braces } from 'lucide-react';
import CopyButton from '../ui/CopyButton';
import { useDebounce } from '../../hooks/useDebounce';

// ─── CONSTANTS ───────────────────────────────────────────────────────────────

const MAX_INPUT_SIZE = 1_000_000; // 1 MB
const DEPTH_LIMIT = 10;
const DEBOUNCE_MS = 300;

const DEFAULT_PRISMA = `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  bio       String?  @db.Text
  age       Int?
  role      Role     @default(USER)
  posts     Post[]
  profile   Profile?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Profile {
  id     String @id @default(uuid())
  avatar String
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  tags      String[]
  metadata  Json?
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
}`;

// ─── PARSER TYPES ────────────────────────────────────────────────────────────

interface PrismaField {
  name: string;
  type: string;
  isNullable: boolean;
  isArray: boolean;
  isId: boolean;
  isUnique: boolean;
  isUpdatedAt: boolean;
  defaultValue: string | null;
  isAutoGenerated: boolean;
  isRelation: boolean;
  dbType: string | null;
}

interface PrismaModel {
  name: string;
  fields: PrismaField[];
  compositeId: string[] | null;
}

interface PrismaEnum {
  name: string;
  values: string[];
}

interface ParseResult {
  enums: PrismaEnum[];
  models: PrismaModel[];
  warnings: string[];
}

// ─── PRISMA SCALAR TYPES ─────────────────────────────────────────────────────

const PRISMA_SCALARS = new Set([
  'String', 'Int', 'Float', 'Decimal', 'Boolean',
  'DateTime', 'Json', 'Bytes', 'BigInt',
]);

const AUTO_GENERATED_DEFAULTS = new Set([
  'autoincrement()', 'cuid()', 'uuid()', 'now()', 'dbgenerated()',
]);

// ─── BLOCK EXTRACTOR ─────────────────────────────────────────────────────────
// Properly matches braces to extract block content — handles nested braces
// that a naive regex like /model\s+\w+\s*{([^}]+)}/g would miss.

function extractBlocks(source: string): Array<{ kind: string; name: string; body: string }> {
  const blocks: Array<{ kind: string; name: string; body: string }> = [];
  // Match block header: `enum Foo {`, `model Bar {`, `generator x {`, `datasource y {`, `type Z {`
  const headerRe = /\b(enum|model|type|generator|datasource)\s+(\w+)\s*\{/g;
  let match: RegExpExecArray | null;

  while ((match = headerRe.exec(source)) !== null) {
    const kind = match[1];
    const name = match[2];
    const openIdx = match.index + match[0].length;
    let depth = 1;
    let i = openIdx;

    while (i < source.length && depth > 0) {
      if (source[i] === '{') depth++;
      else if (source[i] === '}') depth--;
      i++;
    }

    if (depth === 0) {
      blocks.push({ kind, name, body: source.slice(openIdx, i - 1) });
    }
  }

  return blocks;
}

// ─── COMMENT STRIPPER ────────────────────────────────────────────────────────

function stripComments(source: string): string {
  return source
    .split('\n')
    .map(line => {
      // Preserve lines; strip inline // comments (not inside strings)
      const commentIdx = line.indexOf('//');
      return commentIdx >= 0 ? line.slice(0, commentIdx) : line;
    })
    .join('\n');
}

// ─── FIELD PARSER ────────────────────────────────────────────────────────────
// Parses one field line like: `email String @unique`
// or: `role Role @default(USER)`
// or: `author User @relation(fields: [authorId], references: [id])`

function parseField(line: string, knownEnums: Set<string>): PrismaField | null {
  const trimmed = line.trim();
  if (!trimmed || trimmed.startsWith('@@')) return null;

  // Tokenise: split on whitespace but respect parentheses
  const tokens: string[] = [];
  let current = '';
  let parenDepth = 0;

  for (const ch of trimmed) {
    if (ch === '(') { parenDepth++; current += ch; }
    else if (ch === ')') { parenDepth--; current += ch; }
    else if (/\s/.test(ch) && parenDepth === 0) {
      if (current) tokens.push(current);
      current = '';
    } else {
      current += ch;
    }
  }
  if (current) tokens.push(current);

  if (tokens.length < 2) return null;

  const name = tokens[0];
  const rawType = tokens[1];

  // Detect nullable and array
  const isNullable = rawType.endsWith('?');
  const isArray = rawType.endsWith('[]');
  const cleanType = rawType.replace(/[?[\]]/g, '');

  // Determine if this is a relation (non-scalar, non-enum type)
  const isRelation = !PRISMA_SCALARS.has(cleanType) && !knownEnums.has(cleanType);

  // Parse attributes from remaining tokens
  let isId = false;
  let isUnique = false;
  let isUpdatedAt = false;
  let defaultValue: string | null = null;
  let isAutoGenerated = false;
  let dbType: string | null = null;

  for (let i = 2; i < tokens.length; i++) {
    const token = tokens[i];

    if (token === '@id') {
      isId = true;
    } else if (token === '@unique') {
      isUnique = true;
    } else if (token === '@updatedAt') {
      isUpdatedAt = true;
      isAutoGenerated = true;
    } else if (token.startsWith('@default(')) {
      // Extract default value from @default(...)
      const inner = token.slice(9, -1); // Remove @default( and )
      defaultValue = inner;
      if (AUTO_GENERATED_DEFAULTS.has(inner)) {
        isAutoGenerated = true;
      }
    } else if (token.startsWith('@db.')) {
      dbType = token.slice(4); // e.g. "Text", "VarChar(255)"
    }
  }

  // @id with certain defaults is auto-generated
  if (isId && defaultValue && AUTO_GENERATED_DEFAULTS.has(defaultValue)) {
    isAutoGenerated = true;
  }

  return {
    name, type: cleanType, isNullable, isArray, isId, isUnique,
    isUpdatedAt, defaultValue, isAutoGenerated, isRelation, dbType,
  };
}

// ─── MODEL-LEVEL ATTRIBUTE PARSER ────────────────────────────────────────────

function parseModelAttributes(body: string): { compositeId: string[] | null } {
  let compositeId: string[] | null = null;

  const lines = body.split('\n');
  for (const line of lines) {
    const trimmed = line.trim();
    const idMatch = trimmed.match(/^@@id\(\[([^\]]+)\]\)/);
    if (idMatch) {
      compositeId = idMatch[1].split(',').map(s => s.trim());
    }
  }

  return { compositeId };
}

// ─── SCHEMA PARSER ───────────────────────────────────────────────────────────

function parsePrismaSchema(source: string): ParseResult {
  const warnings: string[] = [];
  const cleaned = stripComments(source);
  const blocks = extractBlocks(cleaned);

  // First pass: collect enum names
  const enumNames = new Set<string>();
  const enums: PrismaEnum[] = [];

  for (const block of blocks) {
    if (block.kind === 'enum') {
      enumNames.add(block.name);
      const values = block.body
        .split('\n')
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('@@'));
      enums.push({ name: block.name, values });
    }
  }

  // Second pass: parse models
  const models: PrismaModel[] = [];

  for (const block of blocks) {
    if (block.kind !== 'model' && block.kind !== 'type') continue;

    const { compositeId } = parseModelAttributes(block.body);
    const fields: PrismaField[] = [];
    const lines = block.body.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;

      // Collect warnings for unsupported model-level attributes
      if (trimmed.startsWith('@@index')) {
        warnings.push(`${block.name}: @@index is a DB-level directive — no Zod equivalent generated.`);
        continue;
      }
      if (trimmed.startsWith('@@unique')) {
        warnings.push(`${block.name}: @@unique is a DB-level constraint — skipped in Zod output.`);
        continue;
      }
      if (trimmed.startsWith('@@map')) {
        warnings.push(`${block.name}: @@map rename detected — Zod uses the Prisma model name.`);
        continue;
      }
      if (trimmed.startsWith('@@')) continue; // Skip any other @@

      const field = parseField(trimmed, enumNames);
      if (field) fields.push(field);
    }

    if (compositeId) {
      warnings.push(`${block.name}: Composite @@id([${compositeId.join(', ')}]) detected — all listed fields are marked as required.`);
    }

    models.push({ name: block.name, fields, compositeId });
  }

  return { enums, models, warnings };
}

// ─── ZOD CODE GENERATOR ─────────────────────────────────────────────────────

function mapFieldToZod(field: PrismaField, knownEnums: Set<string>, modelNames: Set<string>, depth: number): string {
  if (depth > DEPTH_LIMIT) return 'z.unknown() /* depth limit reached */';

  let zod: string;

  // ─── Scalars ───
  switch (field.type) {
    case 'String':   zod = 'z.string()'; break;
    case 'Int':      zod = 'z.number().int()'; break;
    case 'Float':    zod = 'z.number()'; break;
    case 'Decimal':  zod = 'z.number()'; break;
    case 'BigInt':   zod = 'z.bigint()'; break;
    case 'Boolean':  zod = 'z.boolean()'; break;
    case 'DateTime': zod = 'z.coerce.date()'; break;
    case 'Json':     zod = 'z.record(z.unknown())'; break;
    case 'Bytes':    zod = 'z.string() /* Base64-encoded bytes */'; break;
    default:
      // ─── Enums ───
      if (knownEnums.has(field.type)) {
        zod = `${field.type}Schema`;
      }
      // ─── Relations ───
      else if (modelNames.has(field.type)) {
        zod = `z.lazy(() => ${field.type}Schema)`;
      } else {
        zod = 'z.unknown()';
      }
  }

  // Array wrapping
  if (field.isArray) {
    zod = `z.array(${zod})`;
  }

  // Nullable
  if (field.isNullable) {
    zod = `${zod}.nullable()`;
  }

  // Defaults (only safe literal values — skip function defaults)
  if (field.defaultValue && !AUTO_GENERATED_DEFAULTS.has(field.defaultValue)) {
    const dv = field.defaultValue;
    if (dv === 'true' || dv === 'false') {
      zod = `${zod}.default(${dv})`;
    } else if (/^-?\d+(\.\d+)?$/.test(dv)) {
      zod = `${zod}.default(${dv})`;
    } else if (/^".*"$/.test(dv)) {
      zod = `${zod}.default(${dv})`;
    } else if (knownEnums.has(field.type)) {
      // Enum default like @default(USER) → .default('USER')
      zod = `${zod}.default('${dv}')`;
    }
  }

  return zod;
}

function generateZodOutput(result: ParseResult): string {
  if (result.enums.length === 0 && result.models.length === 0) {
    return '// No models or enums found. Paste a valid Prisma schema.';
  }

  const knownEnums = new Set(result.enums.map(e => e.name));
  const modelNames = new Set(result.models.map(m => m.name));
  const lines: string[] = [];

  lines.push("import { z } from 'zod';");
  lines.push('');

  // ─── Enums ───
  if (result.enums.length > 0) {
    lines.push('// ─── Enums ───────────────────────────────────────────────────────');
    lines.push('');

    for (const en of result.enums) {
      const vals = en.values.map(v => `'${v}'`).join(', ');
      lines.push(`export const ${en.name}Schema = z.enum([${vals}]);`);
      lines.push(`export type ${en.name} = z.infer<typeof ${en.name}Schema>;`);
      lines.push('');
    }
  }

  // ─── Models ───
  if (result.models.length > 0) {
    lines.push('// ─── Models ──────────────────────────────────────────────────────');
    lines.push('');

    for (const model of result.models) {
      // Determine which fields are auto-generated (for CreateInput)
      const autoFields: string[] = [];

      lines.push(`export const ${model.name}Schema = z.object({`);

      for (const field of model.fields) {
        const zodStr = mapFieldToZod(field, knownEnums, modelNames, 0);

        // Build inline comment for notable attributes
        const notes: string[] = [];
        if (field.isId) notes.push('@id');
        if (field.isUnique) notes.push('@unique');
        if (field.isUpdatedAt) notes.push('@updatedAt');
        if (field.dbType) notes.push(`@db.${field.dbType}`);
        if (field.isRelation) notes.push('relation');

        const comment = notes.length > 0 ? ` // ${notes.join(', ')}` : '';
        lines.push(`  ${field.name}: ${zodStr},${comment}`);

        if (field.isAutoGenerated || field.isUpdatedAt) {
          autoFields.push(field.name);
        }
      }

      lines.push('});');
      lines.push('');
      lines.push(`export type ${model.name} = z.infer<typeof ${model.name}Schema>;`);

      // Generate CreateInput schema (omits auto-generated fields)
      if (autoFields.length > 0) {
        const omitObj = autoFields.map(f => `${f}: true`).join(', ');
        lines.push('');
        lines.push(`// Input schema — omits auto-generated fields`);
        lines.push(`export const ${model.name}CreateInputSchema = ${model.name}Schema.omit({ ${omitObj} });`);
        lines.push(`export type ${model.name}CreateInput = z.infer<typeof ${model.name}CreateInputSchema>;`);
      }

      lines.push('');
    }
  }

  return lines.join('\n').trimEnd();
}

// ─── REACT COMPONENT ─────────────────────────────────────────────────────────

export default function PrismaToZod() {
  const [input, setInput] = useState(DEFAULT_PRISMA);
  const [warning, setWarning] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const debouncedInput = useDebounce(input, DEBOUNCE_MS);

  // ─── Chrome Extension Integration ──────────────────────────────────────
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const incoming = params.get('input');
    if (incoming) {
      setInput(incoming);
      window.history.replaceState({}, '', window.location.pathname);
    }
  }, []);

  // ─── Derived Output ────────────────────────────────────────────────────
  const output = useMemo(() => {
    setError(null);
    setWarning(null);

    if (!debouncedInput.trim()) return '// Paste your Prisma schema here...';

    if (debouncedInput.length > MAX_INPUT_SIZE) {
      setWarning('Schema exceeds 1 MB. Processing may slow down your device.');
    }

    try {
      const result = parsePrismaSchema(debouncedInput);

      if (result.warnings.length > 0) {
        setWarning(result.warnings.join(' • '));
      }

      return generateZodOutput(result);
    } catch {
      setError('Failed to parse schema. Check your Prisma syntax.');
      return '// Error parsing schema. Please ensure it is valid Prisma syntax.';
    }
  }, [debouncedInput]);

  // ─── Handlers ──────────────────────────────────────────────────────────
  const handleClear = useCallback(() => {
    setInput('');
    setError(null);
    setWarning(null);
  }, []);

  const handleReset = useCallback(() => {
    setInput(DEFAULT_PRISMA);
    setError(null);
    setWarning(null);
  }, []);

  // Hydration signal for E2E tests (client:idle defers hydration)
  const rootRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    rootRef.current?.setAttribute('data-hydrated', 'true');
  }, []);

  return (
    <div ref={rootRef} className="max-w-6xl mx-auto space-y-6">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 min-h-150">
        {/* ─── LEFT: Input ─────────────────────────────────────────────── */}
        <div className="flex flex-col bg-slate-900/50 rounded-2xl border border-slate-800 overflow-hidden shadow-sm relative">
          <div className="bg-slate-900/80 backdrop-blur px-4 py-3 border-b border-slate-800 flex justify-between items-center z-10">
            <div className="flex items-center gap-2 text-slate-400">
              <Database className="w-4 h-4 text-indigo-400" />
              <label htmlFor="prismaInput" className="text-xs font-semibold uppercase tracking-wider">Prisma Schema</label>
            </div>
            <div className="flex gap-2">
              <button
                onClick={handleReset}
                className="p-1.5 text-slate-400 hover:text-indigo-400 hover:bg-slate-800 rounded-md transition-colors"
                title="Reset to example"
                aria-label="Reset to example schema"
              >
                <Braces className="w-4 h-4" />
              </button>
              <button
                onClick={handleClear}
                className="p-1.5 text-slate-400 hover:text-red-400 hover:bg-slate-800 rounded-md transition-colors"
                title="Clear"
                aria-label="Clear input"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            </div>
          </div>

          {/* Warnings */}
          {warning && (
            <div className="bg-yellow-900/20 border-b border-yellow-500/50 px-4 py-2 flex items-start gap-2 text-yellow-400 text-xs">
              <AlertTriangle className="w-4 h-4 shrink-0 mt-0.5" />
              <span>{warning}</span>
            </div>
          )}

          <div className="relative flex-1 group">
            <textarea
              id="prismaInput"
              className="absolute inset-0 w-full h-full bg-transparent p-4 font-mono text-sm text-slate-300 focus:outline-none resize-none leading-relaxed"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              spellCheck={false}
              placeholder="Paste your schema.prisma content here..."
            />
            {error && (
              <div className="absolute bottom-4 right-4 bg-red-900/90 border border-red-500/50 text-red-200 text-xs px-3 py-2 rounded-lg flex items-center gap-2 backdrop-blur shadow-lg z-20">
                <AlertCircle className="w-4 h-4" />
                {error}
              </div>
            )}
          </div>
        </div>

        {/* ─── RIGHT: Output ───────────────────────────────────────────── */}
        <div className="flex flex-col bg-slate-950 rounded-2xl border border-slate-800 overflow-hidden shadow-lg relative">
          <div className="bg-slate-900/80 backdrop-blur px-4 py-3 border-b border-slate-800 flex justify-between items-center z-10">
            <div className="flex items-center gap-2 text-sky-400">
              <FileCode2 className="w-4 h-4" />
              <span className="text-xs font-semibold uppercase tracking-wider">Zod Schema</span>
            </div>
            <CopyButton text={output} label="Copy Code" />
          </div>

          <div className="flex-1 relative overflow-auto bg-[#0B1120]">
            {output && !output.startsWith('// Paste') ? (
              <pre className="absolute inset-0 p-4 font-mono text-sm text-sky-300 leading-relaxed overflow-auto">
                {output}
              </pre>
            ) : (
              <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-600 gap-3">
                <Database className="w-10 h-10 opacity-20" />
                <p className="text-sm">Waiting for Prisma schema...</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

// ─── EXPORTED PARSER (for potential testing) ─────────────────────────────────

export { parsePrismaSchema, generateZodOutput };